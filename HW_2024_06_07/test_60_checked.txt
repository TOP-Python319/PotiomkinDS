1 - 2 ✅
2 - 1 ✅
3 - 3 ✅
4 - 2 ✅
5 - 2 ✅
6 - 3 ✅
7 - 1 ✅
8 - 3 ✅
9 - 1 ✅
10 - 2 ✅
11 - ❌, правильный ответ: 4, ваш ответ: 2
12 - ❌, правильный ответ: 4, ваш ответ: 2
13 - 2 ✅
14 - 3 ✅
15 - ❌, правильный ответ: 1, ваш ответ: 2
16 - 1 ✅
17 - 4 ✅
18 - 2 ✅
19 - ❌, правильный ответ: 3, ваш ответ: 1
20 - 1 ✅
21 - 4 ✅
22 - 1 ✅
23 - 3 ✅
24 - 4 ✅
25 - 1 ✅
26 - 3 ✅
27 - 1 ✅
28 - ❌, правильный ответ: 2, ваш ответ: 4
29 - 4 ✅
30 - ❌, правильный ответ: 3, ваш ответ: 4
31 - 2 ✅
32 - 3 ✅
33 - 4 ✅
34 - 4 ✅
35 - 2 ✅
36 - 2 ✅
37 - 2 ✅
38 - 3 ✅
39 - 4 ✅
40 - 3 ✅
41 - 1 ✅
42 - 2 ✅
43 - ❌, правильный ответ: 3, ваш ответ: 2
44 - 1 ✅
45 - 4 ✅
46 - 2 ✅
47 - ❌, правильный ответ: 2, ваш ответ: 3
48 - ❌, правильный ответ: 3, ваш ответ: 4
49 - 4 ✅
50 - 1 ✅
51 - ❌, правильный ответ: 4, ваш ответ: 2
52 - ❌, правильный ответ: 4, ваш ответ: 2
53 - ❌, правильный ответ: 1, ваш ответ: 4
54 - 3 ✅
55 - 4 ✅
56 - 4 ✅
57 - 2 ✅
58 - 4 ✅
59 - 1 ✅
60 - ❌, правильный ответ: 3, ваш ответ: 4

##############################
Правильных ответов: 47
Не правильных ответов: 13 [11, 12, 15, 19, 28, 30, 43, 47, 48, 51, 52, 53, 60]
Пропущено ответов: 0 

За каждый правильный ответ вы получаете 0.2 балла.
При дробной оценке округление в большую сторону.
Ваш балл: 10
##############################

Вопрос 11: 
    Метод __len__ используется для получения длины объекта.
    Он должен возвращать целое число, представляющее длину объекта.
    Пример:
    ```python
    class MyClass:
        def __init__(self, items):
            self.items = items

        def __len__(self):
            return len(self.items)
    ```
    
Вопрос 12: 
    Метод __new__ используется для создания новых объектов.
    Он вызывается перед методом __init__ и может быть использован для создания неизменяемых объектов.
    Пример:
    ```python
    class MyClass:
        def __new__(cls, *args, **kwargs):
            instance = super().__new__(cls)
            return instance

        def __init__(self, value):
            self.value = value
    ```
    
Вопрос 15: 
    Шаблон проектирования "Одиночка" (Singleton) используется для создания единственного экземпляра класса.
    Это полезно, когда необходимо ограничить количество экземпляров класса до одного, например, для управления доступом к ресурсу.
    Пример:
    ```python
    class Singleton:
        _instance = None

        def __new__(cls, *args, **kwargs):
            if not cls._instance:
                cls._instance = super().__new__(cls)
            return cls._instance
    ```
    
Вопрос 19: 
    Функция setattr используется для установки значения атрибута объекта.
    Она принимает три аргумента: объект, имя атрибута и значение атрибута.
    Пример:
    ```python
    class Hero:
        pass

    hero = Hero()
    setattr(hero, 'damage', 100)
    ```
    
Вопрос 28: 
    Геттер-методы помогают предотвратить несанкционированный доступ к атрибутам экземпляра.
    Это позволяет контролировать, как и когда атрибуты могут быть изменены, что делает код более безопасным и управляемым.
    Пример:
    ```python
    class MyClass:
        def __init__(self, value):
            self._value = value

        def get_value(self):
            return self._value
    ```
    
Вопрос 30: 
    Первый аргумент в @classmethod — это класс, который передается в метод.
    Это позволяет методу получать доступ к атрибутам и другим методам класса.
    Пример:
    ```python
    class MyClass:
        class_attr = 'class attribute'

        @classmethod
        def class_method(cls):
            print(cls.class_attr)
    ```
    
Вопрос 43: 
    Порядок разрешения методов (MRO) в Python используется для определения, какой метод будет вызван, если он определен в нескольких классах в иерархии наследования.
    Это позвочает избежать конфликтов имен и обеспечить правильное выполнение методов.
    Пример:
    ```python
    class A:
        pass

    class B(A):
        pass

    class C(B):
        pass

    print(C.__mro__)  # (<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)
    ```
    
Вопрос 47: 
    Атрибут __slots__ используется для оптимизации использования памяти в Python.
    Он ограничивает количество атрибутов, которые можно добавить к экземпляру класса, что помогает уменьшить потребление памяти.
    Пример:
    ```python
    class MyClass:
        __slots__ = ['attr1', 'attr2']

        def __init__(self, attr1, attr2):
            self.attr1 = attr1
            self.attr2 = attr2
    ```
    
Вопрос 48: 
    Создание собственного класса исключений позволяет обрабатывать ошибки, которые не покрываются встроенными классами исключений.
    Это позволяет определить специфические исключения, которые могут быть использованы для обработки ошибок в вашем коде.
    Пример:
    ```python
    class MyCustomError(Exception):
        pass

    raise MyCustomError("This is a custom error")
    ```
    
Вопрос 51: 
    Абстрактные методы в Python должны быть определены без реализации.
    Это означает, что метод должен быть объявлен, но не должен содержать код реализации.
    Пример:
    ```python
    from abc import ABC, abstractmethod

    class MyAbstractClass(ABC):
        @abstractmethod
        def my_abstract_method(self):
            pass
    ```
    
Вопрос 52: 
    Если подкласс не реализует все абстрактные методы абстрактного базового класса, произойдет ошибка в момент вызова класса.
    Это означает, что подкласс не может быть создан, пока он не реализует все абстрактные методы.
    Пример:
    ```python
    from abc import ABC, abstractmethod

    class MyAbstractClass(ABC):
        @abstractmethod
        def my_abstract_method(self):
            pass

    class MyConcreteClass(MyAbstractClass):
        pass

    obj = MyConcreteClass()  # TypeError: Can't instantiate abstract class MyConcreteClass with abstract methods my_abstract_method
    ```
    
Вопрос 53: 
    Модуль dataclasses в Python содержит функции для создания классов данных.
    Это позволяет легко определить классы, которые используются для хранения данных, с минимальным количеством кода.
    Пример:
    ```python
    from dataclasses import dataclass

    @dataclass
    class MyDataClass:
        value: int
    ```
    
Вопрос 60: 
    Статический метод не имеет доступа к экземпляру и классу через self и cls.
    Это позволяет определять методы, которые не зависят от состояния экземпляра или класса.
    Пример:
    ```python
    class MyClass:
        @staticmethod
        def static_method():
            print("This is a static method")
    ```
    
